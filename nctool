#!/usr/bin/env python3

import sys
import os
import stat
import json
import urllib.parse
import sqlite3
import requests
from bs4 import BeautifulSoup

dbname = ".db.sqlite3"
rootdir = sys.argv[2] if len(sys.argv) >= 3 and sys.argv[2] else "."
postsdir = os.path.join(rootdir, "posts")

def hidden(f): return f[0] == "."

class Post():
	def __init__ (self, pathname):
		self.pathname = pathname
		self.mtime = os.stat(self.pathname).st_mtime
		with open(self.pathname, "r", encoding="UTF-8") as f:
			contents = f.read()
		soup = BeautifulSoup(contents, "html.parser")
		tmp = soup.find(attrs={"name":"keywords"})
		self.keywords = set(tmp["content"].strip().split(", ")) if tmp else set()
		tmp = soup.find(attrs={"name":"date"})
		self.date = tmp["content"].strip() if tmp else "0000-00-00"
		self.title = str(soup.select_one("main > h1").extract().renderContents(), encoding="utf8").strip()
		self.contents = str(soup.main.renderContents(), encoding="utf8").strip()

class Template():
	def __init__ (self):
		with open(os.path.join(rootdir, ".template.html"), "r", encoding="UTF-8") as f:
			contents = f.read()
		soup = BeautifulSoup(contents, "html.parser")
		self.title = str(soup.title.renderContents(), "utf8").strip()
		tmp = soup.find(attrs={"name":"url"})
		self.url = tmp["content"].strip() if tmp else "localhost"
		tmp = soup.find(attrs={"name":"description"})
		self.description = tmp["content"].strip() if tmp else "localhost"
		self.contents = contents.strip()

def push():
	def remote_files (rootdir, user, password):
		r = requests.get("https://neocities.org/api/list", auth=(user, password))
		if (r.status_code != 200): quit()
		rjson = json.loads(r.text)
		if (rjson["result"] != "success"): quit()
		if (os.sep != "/"):
                        for entry in rjson["files"]:
                                entry["path"] = entry["path"].replace("/", os.sep)
		return {
			os.path.join(rootdir, entry["path"]): { "size": entry["size"] }
			for entry in rjson["files"] if not entry["is_directory"]
		}

	def local_files (rootdir):
		localfiles = dict()
		for root, dirs, files in os.walk(rootdir):
			for f in files:
				if hidden(f): continue
				pathname = os.path.join(root, f)
				stats = os.stat(pathname)
				localfiles[pathname] = { "size": stats.st_size }
		return localfiles

	def comparison (remote, local):
		rset, lset = set(remote), set(local)
		onlyremote = rset.difference(lset)
		onlylocal = lset.difference(rset)
		common = rset.intersection(lset)
		for f in common:
			if remote[f]["size"] != local[f]["size"]:
				if (remote[f]["size"] == None) or (local[f]["size"] == None):
					quit("%s remote and local file types differ." % f)
				else: onlylocal.add(f)
		return onlyremote, onlylocal

	def remove_files (rmlist, rootdir, user, password):
		paths = [os.path.relpath(path, rootdir) for path in rmlist]
		print("Removing", " ".join(rmlist))
		if (os.sep != "/"): paths = [path.replace(os.sep, "/") for path in paths]
		r = requests.post(
			"https://neocities.org/api/delete",
			auth=(user, password), 
			data={ "filenames[]": paths }
		)
		print(r.status_code)

	def post_files (addlist, rootdir, user, password):
		files = {os.path.relpath(path, rootdir):open(path, "rb") for path in addlist}
		if (os.sep != "/"): files = {k.replace(os.sep, "/"):files[k] for k in files}
		print("Posting", " ".join(addlist))
		r = requests.post(
			"https://neocities.org/api/upload",
			auth=(user, password),
			files=files
		)
		print(r.status_code)
	
	user, password = input("Username: "), input("Password: ")
	rmlist, addlist = comparison(
		remote_files(rootdir, user, password),
		local_files(rootdir))
	if not rmlist: print("No files to delete")
	else: remove_files(rmlist, rootdir, user, password)
	if not addlist: print("No files to upload")
	else: post_files(addlist, rootdir, user, password)

def render():
	tpl = Template()
	def render_post_short(row):
		template = """<tr><td class="date">{DATE}</td><td><h1><a href="{URL}">{TITLE}</a></h1></td></tr>"""
		return template.format(
			URL=row[0],
			TITLE=row[1],
			DATE=row[3]
		)
	def render_post_long(row):
		template = """<article><div class="date">{DATE}</div><h1><a href="{URL}">{TITLE}</a></h1>{CONTENTS}</article>"""
		return template.format(
			URL=row[0],
			TITLE=row[1],
			DATE=row[3],
			CONTENTS=row[4]
		)

	def render_rss_item(row):
		template = """<item><title>{TITLE}</title><link>{URL}</link><guid>{URL}</guid><description>{DESCRIPTION}</description><pubDate>{DATE}</pubDate></item>"""
		url = os.path.join(tpl.url, urllib.parse.quote(row[0]))
		return template.format(
			TITLE=row[1],
			URL=url,
			DATE=row[3],
			DESCRIPTION="<![CDATA["+row[4]+"]]>"
		)
	
	def render_rss_feed(items):
		template = """<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0"><channel><title>{TITLE}</title><link>{URL}</link><description>{DESCRIPTION}</description>{ITEMS}</channel></rss>"""
		return template.format(
			ITEMS="".join(items),
			URL=tpl.url,
			TITLE=tpl.title,
			DESCRIPTION=tpl.description
		)
	
	def render_index(items, keywords):
		template = tpl.contents.replace("<main>", """<main class="index">\n{ITEMS}""")
		return template.format(
			ITEMS="".join(items),
			DATE="date",
			KEYWORDS=", ".join(keywords)
		)
	
	def render_archive(items, date, keywords):
		template = tpl.contents.replace("<main>", """<main class="archive">\n<table>{ITEMS}</table>""")
		return template.format(
			ITEMS="".join(items),
			DATE="date",
			KEYWORDS=", ".join(keywords)
		)
	
	def archive(rows):
		keywords = {row[2] for row in rows}
		items = [render_post_short(row) for row in rows]
		with open("archive.html", "w", encoding="UTF-8") as f:
			f.write(render_archive(items, rows[0][3], keywords))
			print("Wrote", "archive.html")
	
	def rss(rows):
		items = [render_rss_item(row) for row in rows]
		with open("rss.xml", "w", encoding="UTF-8") as f:
			f.write(render_rss_feed(items))
			print("Wrote", "rss.xml")
	
	def index(rows):
		keywords = {row[2] for row in rows}
		items = [render_post_long(row) for row in rows]
		with open("index.html", "w", encoding="UTF-8") as f:
			f.write(render_index(items, keywords))
			print("Wrote", "index.html")
	
	c = sqlite3.connect(dbname)
	rows = c.execute("SELECT * FROM posts ORDER BY date DESC").fetchall()
	archive(rows)
	rows10 = [r + (Post(r[0]).contents,) for r in rows[:10]]
	rss(rows10)
	index(rows10)

def init():
	if os.path.isfile(dbname): os.remove(dbname)
	c = sqlite3.connect(dbname)
	c.execute("""CREATE TABLE posts (pathname TEXT PRIMARY KEY, title TEXT, keywords TEXT, date TEXT)""")
	data = os.listdir(postsdir)
	data.sort()
	data = [os.path.join(postsdir, f) for f in data if not hidden(f)]
	for f in data:
		f = Post(f)
		c.execute(
			"INSERT INTO posts VALUES (?,?,?,?)",
			(f.pathname, f.title, ", ".join(f.keywords), f.date)
		)
	c.commit()

def commit():
	c = sqlite3.connect(dbname)
	rows = set([row[0] for row in c.execute("SELECT pathname FROM posts")])
	files = set([os.path.join(postsdir, f) for f in os.listdir(postsdir)])
	for f in files.difference(rows):
		f = Post(f)
		c.execute(
			"INSERT INTO posts VALUES (?,?,?,?)",
			(f.pathname, f.title, ", ".join(f.keywords), f.date)
		)
		print("Added", f.pathname)
	for r in rows.difference(files):
		c.execute("DELETE FROM posts WHERE pathname=?", (r,))
		print("Removed", r)
	c.commit()

def main(argv):
	if len(argv) < 2: sys.exit(1)
	elif argv[1] == "push": push()
	elif argv[1] == "init": init()
	elif argv[1] == "render": render()
	elif argv[1] == "commit": commit()
	else: sys.exit(1)

if __name__ == "__main__": main(sys.argv)
