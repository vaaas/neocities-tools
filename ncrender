#!/usr/bin/env python3
import sys, os, time, json, string

RS = chr(30)
CONF = json.loads(open("config").read())
DIGITS = string.digits + string.ascii_letters
FORCE = False

def main(pathname, args):
	global FORCE
	FORCE = args and args[0] == "-f"
	posts = open(pathname, "r")
	count = item_count(posts)
	streams = { k : Stream() for k in count }
	streams["total"] = Stream()
	streams["total"].pipe(GroupBy(100)).pipe(Subscriber("index%s.html", count["total"], pagination=True, initial=render_frontpage))
	streams["total"].pipe(Last(100)).pipe(Subscriber("rss.xml", count["total"], render=render_rss))
	streams["article"].pipe(Subscriber("articles/index.html", count["article"]))
	for x in item_stream(posts):
		item = parse(x)
		streams[x.ptype].write(item)
		streams["total"].write(item)
	for x in streams: streams[x].end()

def make(target, deps, fn):
	if FORCE or younger(target, deps):
		print("Making \033[1m\033[92m%s\033[0m" % (target))
		fn()

def younger(x, xs):
	own = os.path.getmtime(x) if os.path.isfile(x) else -1
	others = max(map(timestamp, xs))
	return own < others

class Item:
	def __init__(self, stamp, ptype, content):
		self.timestamp = int(stamp)
		self.ptype = ptype
		self.content = content

def ranges(x, lim=CONF["items"]):
	div, mod = divmod(x, lim)
	xs = [ range(i*lim, (i+1)*lim) for i in range(div) ]
	if mod > 20: xs.append(range(div*lim, div*lim + mod))
	elif mod > 0: xs[-1] = range(xs[-1].start, xs[-1].stop + mod)
	return xs

def render_frontpage(items, **options):
	body = (navhead(**options) +
		"<main>" +
		linejoin(map(render_item, reversed(items))) +
		"</main>")
	with open("templates/frontpage.html", "r") as fp:
		tpl = fp.read(-1)
	return tpl.replace("{{BODY}}", body)

def render_index(items, **options):
	body = (navhead(**options) +
		"<main>" +
		linejoin(map(render_item, reversed(items))) +
		"</main>")
	with open("templates/index.html", "r") as fp:
		tpl = fp.read(-1)
	return tpl.replace("{{BODY}}", body)

def render_item(item):
	return ('<article id="%s"><span class="data">%s</span>%s</article>' %
		(guid(item.timestamp), ymd(item.timestamp), item.content))

def render_rss(items, **options):
	body = linejoin(map(render_item_rss, reversed(items)))
	with open("templates/rss.xml", "r") as fp:
		tpl = fp.read(-1)
	return (tpl
		.replace("{{PUBDATE}}", rfctime(items[-1].timestamp))
		.replace("{{BODY}}", body))

def render_item_rss(item):
	g = guid(item.timestamp)
	return ("<item>" +
		"<title>New post on %s (%s)</title>" % (CONF["sitename"], g) +
		"<guid isPermaLink=\"false\">post/%s</guid>" % (g,) +
		"<pubDate>%s</pubDate>" % (rfctime(item.timestamp),) +
		"<description>%s</description>" % (escape(absolute_links(item.content)),) +
		"<link>https://%s.neocities.org/#%s</link>" %(CONF["sitename"], g) +
		"</item>")

def navhead(p=None, n=None, up=False):
	return ("<nav>" +
		("<a href=\"%s\">← Previous</a>" % (p,) if p else "") +
		("<a href=\"../\">↑ Up</a>" if up else "") +
		("<a href=\"%s\">Next →</a>" % (n,) if n else "") +
		"</nav>")

def escape(x):
	for i in [("&", "&amp;"), ("<", "&lt;"), (">", "&gt;")]:
		x = x.replace(*i)
	return x

def int_to_base(x, base):
	if x == 0: return DIGITS[0]
	xs = []
	while x:
		x, mod = divmod(x, base)
		xs.append(DIGITS[mod])
	return emptyjoin(xs.reverse())

def absolute_links(x):
	for i in ["href", "src"]:
		x = x.replace(
			'%s="/' % (i,),
			'%s="https://%s.neocities.org/' % (i, CONF["sitename"]))
	return x

def item_stream(fp, block_size=2048):
	data = fp.read(block_size)
	while True:
		i = data.find(RS, 1)
		if i != -1:
			yield data[:i]
			data = data[i:]
		else:
			x = fp.read(block_size)
			if x == "": break
			data += x
	if not data == "": yield data

def item_count(x):
	c = { "total": 0 }
	for i in map(parse, item_stream(x)):
		c["total"] += 1
		if not i.ptype in c: c[i.ptype] = 1
		else: c[i.ptype] += 1
	return c

def write(f, x):
	with open(f, "w") as p: p.write(x)

class Stream():
	readers = []
	def read(self, x): pass
	def write(self, x):
		for i in self.readers: i.read(x)
	def listen(self, x):
		self.readers.append(x)
		return self
	def pipe(self, x):
		self.readers.append(x)
		return x
	def end(self, x=None):
		if x: self.write(x)
		self.write(StopIteration)

class GroupBy(Stream):
	def __init__(self, n, margin=20):
		self.xs = []
		self.n = n
		self.margin = margin
	def read(self, x):
		if x is StopIteration: return self.end(self.xs)
		self.xs.append(x)
		if len(self.xs) == self.n+self.margin:
			self.write(self.xs[:self.n])
			self.xs = self.xs[self.n:]

class Last(Stream):
	def __init__(self, n):
		self.xs = []
		self.n = n
	def read(self, x):
		if x is StopIteration: return self.end(self.xs)
		if len(self.xs) == self.n: self.xs.pop(0)
		self.xs.append(x)

class Subscriber(Stream):
	def __init__(self, name, count, pagination=False, render=render_index, initial=None):
		self.queue = []
		self.c = None
		self.p = None
		self.n = None
		self.render = render
		self.initial = initial or render
		if pagination:
			for x in ranges(count):
				self.queue.append(name % (str(x.start),) if x.start > 0 else name % ("",))
		else: self.queue.append(name)

	def read(self, x):
		self.p = self.c
		self.c = self.queue.pop()
		self.n = self.queue[-1] if self.queue else None
		fn = self.render if self.queue else self.initial
		make(self.c, x, lambda y: fn(x, n=self.n, p=self.p, up="/" in self.c))

def parse(x): return Item(*x.strip().split("\n", 2))
def timestamp(x): return x.timestamp
def guid(x): return int_to_base(x, 62)
def ymd(x): return time.strftime("%Y-%m-%d", time.gmtime(x))
def rfctime(x): return time.strftime("%a, %d %b %Y %H:%M:%S +0000", time.gmtime(x))
def linejoin(x): return "\n".join(x)
def emptyjoin(x): return "".join(x)

if __name__ == "__main__": main("posts", sys.argv[1:])
