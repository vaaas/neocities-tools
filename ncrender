#!/usr/bin/env python3

import sys
import os
import re
import time
import json
import lxml.etree as ET
from glob import glob
from jinja2 import Environment, FileSystemLoader

TPL = Environment(loader=FileSystemLoader("templates"))
CONF = json.load(open("config", "r"))
CONF["about"] = open("about.html").read()

def type_filter(thetype, thestuff):
	return filter(lambda x: x.type is thetype, thestuff)

class Util:
	def now():
		return time.strftime("%a, %d %b %Y %H:%M:%S +0000")

	def full_url(partial):
		return CONF["url"] + Util.url_nohost(partial)

	def url_nohost(partial):
		p = partial.split("/")
		if p[-1] == "index.html": p[-1] = ""
		if p[0] != "": p.insert(0, "")
		return "/".join(p)

	def stamp_to_rfc822(timestamp):
		return time.strftime(
			"%a, %d %b %Y %H:%M:%S +0000",
			time.gmtime(timestamp))

	def stamp_to_ymd(timestamp):
		return time.strftime(
			"%Y-%m-%d",
			time.gmtime(timestamp))
	
	def gen_title(item):
		return "%s %d" % (item.type, item.ctime)
	
	def gen_uri(item):
		return Util.full_url("%s/%d" % (item.type, item.ctime))
	
def paginate_index(collection, name="index%s.html", lim=CONF["items"]):
	length = len(collection)
	div, mod = divmod(count, lim)
	items = []
	for i in range(div if mod == 0 else div+1):
		items.append({
			"name": name % (str(i*lim,)),
			"items": collection[i*lim:(i+1)*lim]})
	items[-1]["name"] = name % ("",)
	for i in range(len(args)):
		args[i]["prev"] = items[i - 1]["name"] if i > 0 else None
		args[i]["next"] = items[i + 1]["name"] if i + 1 < length else None
	return items

def write(path, what):
	with open(path, "w") as fil:
		fil.write(compactify(what))

def copy(target, source):
	tfile = open(target, "w")
	sfile = open(source.pathname, "r")
	tfile.write(sfile.read())
	tfile.close()
	sfile.close()

def compactify(string):
	string = re.sub(r"\s+", " ", string, flags=re.MULTILINE)
	return string

def tostring(tree):
	return ET.tostring(tree, encoding="unicode", method="xml")

def econtents(elem):
	string = tostring(elem)
	length = len("<%s>" % (elem.tag,))
	start = string.find("<%s>" % (elem.tag,))
	end = string.rfind("</%s>" % (elem.tag,))
	return string[start+length:end]

def linkify(root):
	def doit(elem, attr):
		if elem.attrib[attr][0] == "/":
			elem.attrib[attr] = Util.full_url(elem.attrib[attr])
	hrefs = root.findall("//*[@href]")
	srcs = root.findall("//*[@src]")
	for elem in hrefs: doit(elem, "href")
	for elem in srcs: doit(elem, "src")
	return root

def inner_text(elem):
	def it_help (elem):
		return ((elem.text or "") +
			"".join([it_help(i) for i in elem]) +
			(elem.tail or ""))
	return (elem.text or "") + "".join([it_help(i) for i in elem])

def html_escape(string):
	return (string.replace("&", "&amp;")
		.replace("<", "&lt;")
		.replace(">", "&gt;"))

class Target:
	def __init__(self, pathname, reqs, callback):
		self.pathname = pathname
		self.reqs = reqs
		self.callback = callback

	def make(self):
		print("‘\033[1m\033[92m" + self.pathname + "\033[0m’" + ":",
			" ".join([a.pathname for a in self.reqs]))
		self.callback(self.pathname, self.reqs)

	def makep(self):
		own = (os.path.getmtime(self.pathname)
			if os.path.isfile(self.pathname) else -1)
		others = [a.mtime for a in self.reqs]
		others.sort()
		return own < others[-1]

class PaginatedTarget(Target):
	def __init__(self, pathname, reqs, prev, next, callback):
		super(PaginatedTarget, self).__init__(pathname, reqs, callback)
		self.reqs = reqs
		self.prev = prev

	def make(self):
		print("‘\033[1m\033[92m" + self.pathname + "\033[0m’" + ":",
			" ".join([a.pathname for a in self.reqs]))
		self.callback(self.pathname, self.reqs, self.prev, self.next)

class XMLFile:
	def __init__ (self, pathname):
		self.pathname = pathname
		stat = os.stat(self.pathname)
		self.mtime = stat.st_mtime
		self.size = stat.st_size
		self.tree = linkify(ET.parse(self.pathname))
		self.ctime = int(
			self.tree.find("./head/meta[@name='timestamp']")
			.attrib["content"])
		self.title = self.tree.find("./body/h1")
		self.title = (None if self.title is None
			else html_escape(inner_text(self.title)))
		self.blurb = tostring(self.tree.find("./body//p[1]"))

class Article(XMLFile):
	type = "Article"
	def __init__(self, pathname):
		super(Article, self).__init__(pathname)
		self.href = Util.url_nohost("/".join(self.pathname.split("/")[1:]))
		self.body = econtents(self.tree.find("./body"))
		del self.tree

class Note(XMLFile):
	type = "Note"
	def __init__(self, pathname):
		super(Note, self).__init__(pathname)
		self.href = "/"
		del self.tree

class Link(XMLFile):
	type = "Link"
	def __init__(self, pathname):
		super(Link, self).__init__(pathname)
		self.href = html_escape(
			self.tree.find("./body/h1/a[1]")
			.attrib["href"])
		del self.tree

class Picture(XMLFile):
	type = "Picture"
	def __init__(self, pathname):
		super(Picture, self).__init__(pathname)
		self.href = html_escape(
			self.tree.find("./body/p/a[1]")
			.attrib["href"])
		del self.tree

class Video(XMLFile):
	type = "Video"
	def __init__(self, pathname):
		super(Video, self).__init__(pathname)
		self.href = html_escape(
			self.tree.find("./body/h1/a[1]")
			.attrib["href"])
		del self.tree

class App(XMLFile):
	type = "App"
	def __init__(self, pathname):
		self.pathname = pathname
		stat = os.stat(self.pathname)
		self.mtime = stat.st_mtime
		self.size = stat.st_size
		self.tree = ET.parse(self.pathname, parser=ET.HTMLParser())
		self.ctime = int(
			self.tree.find("./head/meta[@name='timestamp']")
			.attrib["content"])
		self.title = html_escape(
			inner_text(
				self.tree.find("./head/title")))
		self.href = Util.url_nohost(
			"/".join(
				self.pathname.split("/")[1:]))
		self.blurb = ET.Element("p")
		self.blurb.text = (self.tree.find("./head/meta[@name='description']")
			.attrib["content"])
		self.blurb = tostring(self.blurb)

def selector(string):
	return {
		"articles": Article,
		"notes": Note,
		"pictures": Picture,
		"videos": Video,
		"links": Link,
		"apps": App}[string]

def item(xmlfile):
	template = TPL.get_template("item.html")
	return template.render(conf=CONF, item=xmlfile, util=Util,
		title=xmlfile.title, date=Util.stamp_to_rfc822(xmlfile.ctime))

def index(articles, href_prev=None, href_next=None):
	articles.reverse()
	template = TPL.get_template("index.html")
	return template.render(conf=CONF, items=articles, util=Util,
		title=CONF["site"], date=Util.now(),
		href_prev=href_prev, href_next=href_next)

def rss(articles):
	articles.reverse()
	template = TPL.get_template("rss.xml")
	return template.render(conf=CONF, items=articles, util=Util)

def main(args):
	force = len(args) > 0 and args[0] == "-f"

	source = "posts"
	target = "render"

	xmlfiles = [selector(i)(i) for i in glob("posts/**/*html", recursive=True)]
	tgts = []

	for xmlfile in type_filter("Article", xmlfiles):
		tpath = re.sub(r"^posts/", "render/", xml.file.pathname)
		tgts.append(Target(tpath, [xmlfile],
			lambda path, reqs: write(path, item(reqs[0]))))

	for xmlfile in type_filter("App", xmlfiles):
		tpath = re.sub(r"^posts/", "render/", xml.file.pathname)
		tgts.append(Target(tpath, [xmlfile],
			lambda path, reqs: copy(path, reqs[0])))

	tgts.append(Target(
		"render/rss.xml",
		xmlfiles[-CONF["items"]:],
		lambda path, reqs: write(path, rss(reqs))))

	for i in paginate_index(xmlfiles, "/index%s.html"):
		tgts.append(PaginatedTarget(
			"render"+i["name"],
			i["items"],
			i["prev"], i["next"],
			lambda path, reqs, p, n:
				write(path, index(reqs, p, n))))

	tgts.append(
		Target(
			"render/articles/index.html",
			list(type_filter("Article", xmlfiles)),
			lambda path, reqs: write(path, index(reqs))))
	tgts.append(
		Target(
			"render/apps/index.html",
			list(type_filter("App", xmlfiles)),
			lambda path, reqs: write(path, index(reqs))))

	for tgt in tgts:
		if force or tgt.makep():
			tgt.make()

if __name__ == "__main__":
	main(sys.argv[1:])
