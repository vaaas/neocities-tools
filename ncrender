#!/usr/bin/env python3

import sys
import os
import re
import time
import lxml.etree as ET
from copy import deepcopy

CONF = {
	"site": "Vas' Website",
	"desc": "A blog on technology, nerddom, and politics",
	"url": "https://vas.neocities.org" }

def now(): return time.strftime('%a, %d %b %Y %H:%M:%S +0000')
def full_url (partial): return CONF["url"] + partial if partial[0] is "/" else CONF["url"] + "/" + partial
def replace_start (string, old, new): return new + string[:len(what)]

def ranges (n):
	div, mod = divmod(n, 20)
	lst = []
	for i in range(div - 1):
		lst.append((i*20, (i+1)*20))
	if mod < 10:
		lst.append(((div-1)*20, mod+div*20))
	else:
		lst.append(((div-1)*20, div*20))
		lst.append((div*20, mod+div*20))
	return lst

def write(path, what):
	with open(path, "w") as f:
		f.write(compactify(what))

def compactify (s):
	s = re.sub(r"\s+", " ", s, flags=re.MULTILINE)
	return s

def E (tag, attrs={}, children=[], text="", tail=""):
	elem = ET.Element(tag, attrs)
	for child in children: elem.append(child)
	if (text): elem.text = text
	if (tail): elem.tail = tail
	return elem

def stamp_to_rfc822(timestamp):
	return time.strftime(
		'%a, %d %b %Y %H:%M:%S +0000',
		time.gmtime(timestamp))

def stamp_to_ymd(timestamp):
	return time.strftime(
		'%Y-%m-%d',
		time.gmtime(timestamp))

class Target:
	def __init__ (self, pathname, reqs, fn):
		self.pathname = pathname
		self.reqs = reqs
		self.fn = fn
	
	def make(self):
		print(self.pathname, ":", " ".join([a.pathname for a in self.reqs]))
		self.fn(self.pathname, self.reqs)

	def makep (self):
		own = os.path.getmtime(self.pathname) if os.path.isfile(self.pathname) else -1
		others = [a.mtime for a in self.reqs]
		others.sort()
		if own < others[-1]: return True
		else: return False

class XMLFile:
	def __init__ (self, pathname):
		self.pathname = pathname
		self.tree = ET.parse(self.pathname)
		self.mtime = os.path.getmtime(self.pathname)
		self.ctime = int(
			self.tree.find("./head/meta[@name='timestamp']").attrib["value"])
		self.type = self.tree.find("./head/meta[@name='type']").attrib["value"]
		self.typename = {
			"article": "Article",
			"note": "Note" }[self.type]
		if (self.type == "note"):
			self.href = "/"
			self.title = "%s %s" % (self.typename, str(self.ctime))
			self.blurb = deepcopy(self.tree.find(("./body")))
			self.blurb.tag = "p"
		else:
			p = self.pathname.split(os.sep)
			end = len(p) if p[-1] != "index.html" else -1
			self.href = os.path.join("/", *p[1:end])
			self.title = self.tree.find("./head/title").text
			self.blurb = self.tree.find("./body/p[1]")

	def article (self):
		elem = E("article", {"data-post-type": self.type})
		elem.append(E("header", children=[
			E("img", {"class": "emoji", "src": "/pics/%s.svg" % (self.type,)}),
			E("strong", text=" "+self.typename),
			E("data", {"class": "date", "value": str(self.ctime)},
				text=stamp_to_ymd(self.ctime))]))
		if (self.type != "note"):
			elem.append(E("h1", children=[
				E("a", { "href": self.href }, text=self.title)]))
		elem.append(self.blurb)
		return elem
	
	def item (self):
		if self.type == "note":
			desc = ET.CDATA(ET.tostring(self.blurb, encoding="unicode"))
		else:
			desc = ET.CDATA("""%s<p><a href="%s">Read more</a></p>""" % (ET.tostring(self.blurb, encoding="unicode"), full_url(self.href)))
		return E("item", {}, [
			E("title", text=self.title),
			E("link", text=full_url(self.href)),
			E("guid", text=self.title if self.type == "note" else self.href),
			E("pubDate", text=stamp_to_rfc822(self.ctime)),
			E("description", text=desc)])

def HTML (date, title, content):
	if not content.tag is "body": content.tag = "body"
	tree = E("html", {"lang": "en-gb"}, [
		E("head", {}, [
			E("meta", {"charset": "utf-8"}),
			E("meta", {"name": "viewport", "content": "width=device-width, initial-scale=1.0"}),
			E("meta", {"name": "url", "content": CONF["url"]}),
			E("meta", {"name": "author", "content": "Vas"}),
			E("meta", {"name": "description", "content": CONF["desc"]}),
			E("meta", {"name": "date", "content": date}),
			E("link", {"rel": "stylesheet", "href": "/style.css"}),
			E("link", {"rel": "icon", "href": "/favicon.ico?v=2"}),
			E("link", {"rel": "alternate", "href": "/rss.xml", "type": "application/rss+xml"}),
			E("title", text=title) ]),
		content ])
	return "<!DOCTYPE html>" + ET.tostring(tree, encoding="unicode")

def item (xmlfile):
	body = deepcopy(xmlfile.tree.find("./body"))
	pubdate = E("data", text=stamp_to_ymd(xmlfile.ctime))
	header = E("header", {}, [
		E("a", {"href": "/"}, text=CONF["site"]),
		pubdate])
	body.insert(0, E("h1", text=xmlfile.title))
	body.insert(0, header)
	return HTML(
		stamp_to_rfc822(xmlfile.ctime),
		xmlfile.title,
		body)

def index (articles, href_prev=None, href_next=None):
	lst = [a.article() for a in articles]
	lst.reverse()

	header = E("header", {}, [
		E("div", {}, [
			E("img", {"alt": "website icon", "id": "icon", "src": "/pics/icon.jpg"}),
			E("h1", {}, text=CONF["site"])]),
		E("p", text=CONF["desc"]),
		E("nav", {}, [
			E("a", { "href": "/rss.xml"}, text="RSS feed"),
			E("a", { "href": "mailto:whiterocket@outlook.com"}, text="Email"),
			E("a", { "href": "xmpp:vaas@xmpp.jp"}, text="XMPP"),
			E("a", { "href": "https://github.com/vaaas"}, text="GitHub")])])

	if (href_prev or href_next):
		pagenav = E("nav")
		if href_prev: pagenav.append(E("a", {"href": href_prev}))
		if href_next: pagenav.append(E("a", {"href": href_next}))
		header.append(pagenav)

	tree = E("body", {"class": "index"}, [header] + lst)
	return HTML(now(), CONF["site"], tree)

def rss (articles):
	items = [a.item() for a in articles]
	items.reverse()
	tree = E("rss", {"version": "2.0"}, [
		E("channel", {}, [
			E("title", text=CONF["site"]),
			E("link", text=CONF["url"]),
			E("description", text=CONF["desc"]),
			E("pubDate", text=items[0].find("./pubDate").text),
			E("lastBuildDate", text=now()),
			E("language", text="en-gb"),
			E("ttl", text="1440")] + items)])

	return """<?xml version="1.0" encoding="utf-8" ?>""" + ET.tostring(tree, encoding="unicode")

def move (target, reqs):
	os.rename(reqs[0], target)

def main (args):
	FORCE = True if len(args) > 0 and args[0] == "-f" else False

	source = "posts"
	target = "render"

	tgts = []
	xmlfiles = []
	for (root, dirs, files) in os.walk(source):
		xmlfiles += [os.path.join(root, f) for f in files]
	xmlfiles = [XMLFile(f) for f in xmlfiles]
	xmlfiles.sort(key=lambda x: x.ctime)

	for f in [i for i in xmlfiles if i.type != "note"]:
		parts = f.pathname.split(os.sep)
		parts[0] = target
		for i in range(len(parts)-1):
			pathname = os.path.join(*parts[:i+1])
			if not os.path.isdir(pathname): os.mkdir(pathname)
		tgts.append(Target(os.path.join(*parts), [f], lambda me, reqs: write(me, item(reqs[0]))))

	tgts.append(Target(os.path.join(target, "rss.xml"), xmlfiles[:20], lambda me, reqs: write(me, rss(reqs))))

	rng = ranges(len(xmlfiles))
	for (start, end) in rng[:-1]:
		pathname = os.path.join(target, "index" + end + ".html")
		tgts.append(Target(pathname, xmlfiles[start:end], lambda me, reqs: write(me, index(reqs))))
	tgts.append(Target(os.path.join(target, "index.html"), xmlfiles[rng[-1][0]:rng[-1][1]], lambda me, reqs: write(me, index(reqs))))

	for tgt in tgts:
		if FORCE or tgt.makep():
			tgt.make()

if __name__ == "__main__":
	main(sys.argv[1:])
