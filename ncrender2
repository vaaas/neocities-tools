#!/usr/bin/env python3

import sys, os, time, json, string, re
import xml.dom.minidom as xml
from typing import *
T = TypeVar('T')
Document: xml.Node = xml.Document()

CONF: dict = dict()

DIGITS: str = string.digits + string.ascii_letters + '-_'
def int_to_base(x: int, base: int) -> str:
	if x == 0: return DIGITS[0]
	xs: List[str] = []
	while x:
		x, mod = divmod(x, base)
		xs.append(DIGITS[mod])
	return ''.join(reversed(xs))

def ymd(x: int) -> str: return time.strftime('%Y-%m-%d', time.gmtime(x))
def rfctime(x: int) -> str: return time.strftime('%a, %d %b %Y %H:%M:%S +0000', time.gmtime(x))
def guid(x: int) -> str: return int_to_base((x-1483228800)//60, len(DIGITS))
def element_node(x: xml.Node) -> bool: return x.nodeType == xml.Node.ELEMENT_NODE
def text_node(x: xml.Node) -> bool: return x.nodeType == xml.Node.TEXT_NODE
def tag_name(a: str) -> Callable[[xml.Node], bool]: return lambda b: element_node(b) and b.tagName == a
def first(x: Sequence[T]) -> T: return x[0]
def tail(x: Sequence[T]) -> Sequence[T]: return x[1:]
def clone(x: xml.Node) -> xml.Node: return x.cloneNode(deep=True)
def K(a: T) -> Callable[[Any], T]: return lambda b: a

def inner_text(x: xml.Node) -> str:
	text = []
	for n in x.childNodes:
		if text_node(n): text.append(n.data)
		elif element_node(n):
			for t in inner_text(n): text.append(t)
	return ''.join(text)

def maybe(x: Optional[T], good: Callable[[T], Any], bad: Callable[[None], Any]) -> Any:
	if x == None:
		assert x is None
		return bad(x)
	else:
		assert x is not None
		return good(x)

def META(name: str, content: str) -> xml.Node:
	return E('meta', [('name', name), ('content', content)], None)

def LINK(rel: str, href: str, type: Optional[str] = None) -> xml.Node:
	xs = [('rel', rel), ('href', href)]
	if type: xs.append(('type', type))
	return E('link', xs, None)

def HTML(lang: str, head: xml.Node, body: xml.Node) -> xml.Node:
	return E('html', [('lang', lang)], [head, body])

def HEAD(title: str) -> xml.Node:
	return E('head', None, [
		E('meta', [('charset', 'utf8')], None),
		META('viewport', 'width=device-width, initial-scale=1.0'),
		META('url', CONF['url']),
		META('author', CONF['author']),
		META('description', CONF['sitename']),
		LINK('stylesheet', '/style.css'),
		LINK('icon', '/favicon.ico'),
		E('title', None, [CONF['sitename']]),
	])

def E(name: str, attrs: Optional[Iterable[Tuple[str, str]]], children: Optional[Iterable[Union[xml.Node, str]]]) -> xml.Node:
	x: xml.Node = Document.createElement(name)
	if attrs:
		for name, value in attrs:
			x.setAttribute(name, value)
	if children:
		for child in children:
			if isinstance(child, xml.Node):
				x.appendChild(child)
			elif isinstance(child, str):
				x.appendChild(Document.createTextNode(child))
	return x

def aimg(src: str, href: str, alt: Optional[str] = None) -> xml.Node:
	img_attrs = [('src', src)]
	if alt: img_attrs.append(('alt', alt))
	return E('a', [('href', href)], [E('img', img_attrs, None)])

def empty(x: xml.Node) -> xml.Node:
	for c in reversed(x.childNodes):
		x.removeChild(c)

def find(f: Callable[[T], bool], xs: Iterable[T]) -> Optional[T]:
	for x in xs:
		if f(x): return x
	return None

def query_xml(doc: xml.Node, *fs: Callable[[xml.Node], bool]) -> Optional[xml.Node]:
	x = doc
	for f in fs:
		if x == None: return x
		x = find(f, x.childNodes)
	return x

def query_xml_all(x: xml.Node, *fs: Callable[[xml.Node], bool]) -> Generator[xml.Node, None, None]:
	if len(fs) == 0:
		yield x
	else:
		cs: Iterable[xml.Node] = filter(first(fs), x.childNodes)
		for c in cs:
			yield from query_xml_all(c, *tail(fs))

def main():
	def html_final(x: xml.Node) -> str:
		return '<!DOCTYPE html>' + x.toxml()

	def rss_final(x: xml.Node) -> str:
		return '<?xml version="1.0" encoding="UTF-8"?>' + x.toxml()

	global CONF
	document: xml.Node = xml.parse('site.xml')
	site = query_xml(document, tag_name('site'))
	for x in filter(element_node, site.childNodes):
		if x.tagName == 'icon': CONF['icon'] = inner_text(x)
		elif x.tagName == 'sitename': CONF['sitename'] = inner_text(x)
		elif x.tagName == 'links': CONF['links'] = list(map(clone, query_xml_all(x, tag_name('a'))))
		elif x.tagName == 'lang': CONF['lang'] = inner_text(x)
		elif x.tagName == 'url': CONF['url'] = inner_text(x)
		elif x.tagName == 'author': CONF['author'] = inner_text(x)
		elif x.tagName == 'blurb': CONF['blurb'] = clone(x)
		elif x.tagName == 'posts': posts = x

	write('render/index.html',
		html_final(
		frontpage_template(
		list(
		map(render_item,
		query_xml_all(posts, tag_name('post')))))))

	write('render/rss.xml',
		rss_final(
		rss_template(
		list(
		map(render_rss_item,
		query_xml_all(posts, tag_name('post')))))))

	for x in query_xml_all(posts, tag_name('post')):
		if query_xml(x, tag_name('h1')) is None: continue
		write(os.path.join('render', x.getAttribute('filename')), render_post(x))

def render_item(x: xml.Node) -> xml.Node:
	return E('article', [
		('id', guid(int(x.getAttribute('timestamp')))),
		('t', x.getAttribute('tag')),
	], description(x))

def description(x: xml.Node) -> Iterable[xml.Node]:
	if x.hasAttribute('filename'):
		yield E('h1', None, [
			E('a', [('href', '/' + x.getAttribute('filename'))], map(clone, query_xml(x, tag_name('h1')).childNodes)),
		])
		yield from map(clone, query_xml(x, tag_name('p')).childNodes)
	else: return map(clone, x.childNodes)

def render_post(x: xml.Node): pass

def frontpage_template(posts: List[xml.Node]) -> xml.Node:
	distinct_tags: List[str] = sorted(set((x.getAttribute('t') for x in posts)))
	return HTML(CONF['lang'], HEAD(CONF['sitename']),
		E('body', None, [
			E('header', None, [
				aimg(CONF['icon'], '/', 'icon'),
				E('h1', None, [
					CONF['sitename'],
					aimg('/pics/feed-icon.svg', '/rss.xml', 'rss'),
				]),
				E('nav', [('id', 'links')], CONF['links']),
				CONF['blurb'],
			]),
			E('main', None, [
				E('nav', [('id', 'cats')], [
					E('a', [('class', 'active'), ('href', 'all')], ['all']),
					*(E('a', [('href', x)], [x]) for x in distinct_tags)
				]),
				*posts
			]),
			E('script', [('src', '/script.js')], [''])
		])
	)

def rss_template(posts: List[xml.Node]) -> xml.Node:
	return E('rss', [('version', '2.0')], [
		E('channel', None, CONF['sitename']),
		E('link', None, CONF['url']),
		E('atom:link', [('href', os.path.join(CONF['sitename'], 'rss.xml')), ('rel', 'self'), ('type', 'application/rss+xml')], None),
		E('description', None, CONF['sitename']),
		E('pubDate', None, inner_text(query_xml(first(posts), tag_name('pubDate')))),
		E('language', None, CONF['lang']),
		E('ttl', None, ['1440']),
		*posts
	])

def render_rss_item(x: xml.Node) -> xml.Node:
	xguid = guid(int(x.getAttribute('timestamp')))
	xurl = os.path.join(CONF['url'], '#' + xguid)
	return E('item', None, [
		E('title', None, [ maybe(query_xml(x, tag_name('h1')), inner_text, K('New post by %s (%s)' % (CONF['author'], xguid))) ]),
		E('guid', None, [ xurl ]),
		E('pubDate', None, [ rfctime(int(x.getAttribute('timestamp'))) ]),
		E('link', None, [ xurl ]),
		E('description', None, description(x)),
	])

def write(pathname: str, contents: str):
	fp = open(pathname, 'w')
	fp.write(contents)
	fp.close()

main()
